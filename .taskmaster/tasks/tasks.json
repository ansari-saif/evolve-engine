{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Audit and Update React Query Hooks",
        "description": "Verify all existing React Query hooks properly use the updated client services and update their return types to match new API response structures.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Create an inventory of all existing React Query hooks in the codebase\n2. Compare each hook against the updated client services in services.ts\n3. Update hook parameters to match new service method signatures\n4. Update return types to align with types from models.ts\n5. Ensure proper TypeScript typing throughout (no any types)\n6. Use the latest React Query v4+ patterns:\n   - Use the useQuery hook for GET requests\n   - Use useMutation for POST/PUT/DELETE operations\n   - Implement proper queryKey structures for caching\n   - Add proper error typing using the Error type from the client\n\nExample update:\n```typescript\n// Before\nconst useTasks = () => {\n  return useQuery<any[]>('tasks', () => fetchTasks());\n};\n\n// After\nimport { Task } from '../client/models';\nimport { services } from '../client/services';\n\nconst useTasks = () => {\n  return useQuery<Task[], Error>(\n    ['tasks'],\n    () => services.tasks.getTasks(),\n    { staleTime: 5 * 60 * 1000 } // 5 minutes\n  );\n};\n```",
        "testStrategy": "1. Write unit tests for each updated hook using React Testing Library and MSW for API mocking\n2. Verify hooks return the correct data types\n3. Test error scenarios by mocking API failures\n4. Test loading states\n5. Verify hooks use the correct service methods\n6. Test with mock data that matches the updated API response structure",
        "subtasks": [
          {
            "id": 1,
            "title": "Create inventory of existing React Query hooks",
            "description": "Identified the following hooks in the codebase:\n- useTasks.ts\n- useGoals.ts\n- useJobMetrics.ts\n- useProgressLogs.ts\n- useDayLogs.ts\n- useAiService.ts\n\nMissing hooks for:\n- UsersService\n- AiContextService\n- LogService\n- PromptsService",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Audit existing hooks for compliance with standards",
            "description": "Completed audit with the following findings:\n- All hooks correctly use updated client services\n- All hooks properly import and use types from models.ts\n- Hooks use correct React Query v4+ patterns\n- Error handling is consistent using getErrorMessage utility\n- Query keys are properly structured for caching\n- Appropriate stale time configurations (2-5 minutes) are in place",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add explicit return type annotations to existing hooks",
            "description": "Some hooks don't explicitly specify return types for better type safety. Update all existing hooks to include explicit return type annotations for improved type safety and code readability.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create useUsers.ts hook",
            "description": "Implement useUsers.ts hook for the UsersService following the established pattern:\n- Create query hooks for GET operations\n- Create mutation hooks for POST/PUT/DELETE operations\n- Use proper TypeScript types from models.ts\n- Add JSDoc comments for each hook function",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create useAiContext.ts hook",
            "description": "Implement useAiContext.ts hook for the AiContextService following the established pattern:\n- Create query hooks for GET operations\n- Create mutation hooks for POST/PUT/DELETE operations\n- Use proper TypeScript types from models.ts\n- Add JSDoc comments for each hook function",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create useLogs.ts hook",
            "description": "Implement useLogs.ts hook for the LogService following the established pattern:\n- Create query hooks for GET operations\n- Create mutation hooks for POST/PUT/DELETE operations\n- Use proper TypeScript types from models.ts\n- Add JSDoc comments for each hook function",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create usePrompts.ts hook",
            "description": "Implement usePrompts.ts hook for the PromptsService following the established pattern:\n- Create query hooks for GET operations\n- Create mutation hooks for POST/PUT/DELETE operations\n- Use proper TypeScript types from models.ts\n- Add JSDoc comments for each hook function",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Write unit tests for new hooks",
            "description": "Create comprehensive unit tests for all newly created hooks:\n- Test successful API calls\n- Test error handling\n- Verify query invalidation works correctly for mutations\n- Test with realistic mock data that matches API schemas",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Missing React Query Hooks",
        "description": "Identify and implement any missing React Query hooks for services not yet covered in the frontend.",
        "details": "1. Compare the available services in services.ts against existing hooks\n2. Create new hooks for any services without corresponding hooks\n3. Follow the established pattern for hook implementation:\n   - Create a new file in the hooks directory for each service\n   - Implement query hooks for GET operations\n   - Implement mutation hooks for POST/PUT/DELETE operations\n   - Use proper TypeScript types from models.ts\n   - Add JSDoc comments for each hook\n\nExample implementation for a missing hook:\n```typescript\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { services } from '../client/services';\nimport { JobMetric, CreateJobMetricRequest } from '../client/models';\n\n/**\n * Hook to fetch job metrics\n */\nexport const useJobMetrics = (jobId: string) => {\n  return useQuery<JobMetric[], Error>(\n    ['jobMetrics', jobId],\n    () => services.jobMetrics.getJobMetrics(jobId),\n    { staleTime: 60000 }\n  );\n};\n\n/**\n * Hook to create a job metric\n */\nexport const useCreateJobMetric = () => {\n  const queryClient = useQueryClient();\n  \n  return useMutation<JobMetric, Error, CreateJobMetricRequest>(\n    (data) => services.jobMetrics.createJobMetric(data),\n    {\n      onSuccess: (data, variables) => {\n        queryClient.invalidateQueries(['jobMetrics', variables.jobId]);\n      }\n    }\n  );\n};\n```",
        "testStrategy": "1. Create unit tests for each new hook\n2. Test successful API calls\n3. Test error handling\n4. Verify query invalidation works correctly for mutations\n5. Test with realistic mock data that matches API schemas\n6. Verify hooks integrate correctly with the client services",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Enhance Error Handling in Hooks and Components",
        "description": "Implement consistent error handling across all hooks and components using the existing error handling utilities.",
        "details": "1. Import and use the existing getErrorMessage utility for all error handling\n2. Update all components to properly handle error states from hooks\n3. Implement toast notifications for API errors using a library like react-hot-toast or react-toastify\n4. Add error boundaries around key components\n5. Create a reusable ErrorDisplay component for consistent error UI\n6. Implement retry mechanisms for failed requests\n\nExample implementation:\n```typescript\nimport { useQuery } from '@tanstack/react-query';\nimport { services } from '../client/services';\nimport { Task } from '../client/models';\nimport { getErrorMessage } from '../utils/errorHandling';\nimport { toast } from 'react-hot-toast';\n\nexport const useTasks = () => {\n  return useQuery<Task[], Error>(\n    ['tasks'],\n    () => services.tasks.getTasks(),\n    {\n      staleTime: 5 * 60 * 1000,\n      retry: 2,\n      onError: (error) => {\n        const message = getErrorMessage(error);\n        toast.error(`Failed to load tasks: ${message}`);\n      }\n    }\n  );\n};\n\n// In component\nconst TaskList = () => {\n  const { data, error, isLoading } = useTasks();\n  \n  if (isLoading) return <LoadingSpinner />;\n  \n  if (error) {\n    return <ErrorDisplay message={getErrorMessage(error)} />\n  }\n  \n  return (\n    <div>\n      {data?.map(task => <TaskItem key={task.id} task={task} />)}\n    </div>\n  );\n};\n```\n\nCreate a reusable ErrorDisplay component:\n```typescript\nimport { AlertCircle } from 'lucide-react';\n\ninterface ErrorDisplayProps {\n  message: string;\n  retry?: () => void;\n}\n\nexport const ErrorDisplay = ({ message, retry }: ErrorDisplayProps) => {\n  return (\n    <div className=\"p-4 bg-red-50 border border-red-200 rounded-md\">\n      <div className=\"flex items-center\">\n        <AlertCircle className=\"h-5 w-5 text-red-500 mr-2\" />\n        <p className=\"text-red-700\">{message}</p>\n      </div>\n      {retry && (\n        <button \n          onClick={retry}\n          className=\"mt-2 text-sm text-red-600 hover:text-red-800\"\n        >\n          Try again\n        </button>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Test error handling in hooks with mocked API failures\n2. Verify error messages are displayed correctly in components\n3. Test retry functionality\n4. Verify toast notifications appear with correct messages\n5. Test error boundaries catch and display errors properly\n6. Ensure consistent error handling across all components",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Update TodaysTasks Component",
        "description": "Update the TodaysTasks component to properly use the updated task APIs, including correct types, loading states, and error handling.",
        "details": "1. Refactor the TodaysTasks component to use the updated task services\n2. Update the component to use the Task type from models.ts\n3. Implement proper loading states using React Query's isLoading\n4. Add error handling using the enhanced error handling approach\n5. Update any UI elements to match the new data structure\n6. Implement optimistic updates for task status changes\n\nExample implementation:\n```typescript\nimport { useState } from 'react';\nimport { Task } from '../client/models';\nimport { useTasks, useUpdateTask } from '../hooks/useTasks';\nimport { getErrorMessage } from '../utils/errorHandling';\nimport { LoadingSpinner } from './LoadingSpinner';\nimport { ErrorDisplay } from './ErrorDisplay';\nimport { CheckCircle, Circle } from 'lucide-react';\n\nexport const TodaysTasks = () => {\n  const { data: tasks, isLoading, error, refetch } = useTasks();\n  const updateTaskMutation = useUpdateTask();\n  \n  const handleToggleComplete = (task: Task) => {\n    updateTaskMutation.mutate(\n      {\n        id: task.id,\n        status: task.status === 'completed' ? 'pending' : 'completed'\n      },\n      {\n        onError: (error) => {\n          toast.error(`Failed to update task: ${getErrorMessage(error)}`);\n        }\n      }\n    );\n  };\n  \n  if (isLoading) return <LoadingSpinner />;\n  \n  if (error) {\n    return <ErrorDisplay message={getErrorMessage(error)} retry={refetch} />;\n  }\n  \n  const todaysTasks = tasks?.filter(task => {\n    // Filter logic for today's tasks\n    const taskDate = new Date(task.dueDate);\n    const today = new Date();\n    return taskDate.toDateString() === today.toDateString();\n  }) || [];\n  \n  return (\n    <div className=\"space-y-4\">\n      <h2 className=\"text-xl font-bold\">Today's Tasks</h2>\n      {todaysTasks.length === 0 ? (\n        <p className=\"text-gray-500\">No tasks for today</p>\n      ) : (\n        <ul className=\"space-y-2\">\n          {todaysTasks.map(task => (\n            <li key={task.id} className=\"flex items-center p-2 hover:bg-gray-50 rounded\">\n              <button \n                onClick={() => handleToggleComplete(task)}\n                className=\"mr-2\"\n                aria-label={task.status === 'completed' ? 'Mark as incomplete' : 'Mark as complete'}\n              >\n                {task.status === 'completed' ? (\n                  <CheckCircle className=\"h-5 w-5 text-green-500\" />\n                ) : (\n                  <Circle className=\"h-5 w-5 text-gray-400\" />\n                )}\n              </button>\n              <span className={task.status === 'completed' ? 'line-through text-gray-500' : ''}>\n                {task.title}\n              </span>\n              {updateTaskMutation.isLoading && updateTaskMutation.variables?.id === task.id && (\n                <LoadingSpinner className=\"ml-2 h-4 w-4\" />\n              )}\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Write unit tests using React Testing Library\n2. Test rendering with mock task data\n3. Test loading state\n4. Test error state\n5. Test task completion toggle functionality\n6. Test filtering logic for today's tasks\n7. Verify optimistic updates work correctly\n8. Test with various API response scenarios",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Update Form Components with Schema Validation",
        "description": "Update all form components to validate against the new schemas from the client and ensure they use the correct request body types.",
        "details": "1. Import schemas from the client/schemas.ts file\n2. Integrate schemas with form validation libraries (like react-hook-form and zod)\n3. Update form field types to match API request types\n4. Add client-side validation using the schemas\n5. Update form submission to use the correct mutation hooks\n6. Add proper error handling for validation errors\n\nExample implementation using react-hook-form and zod:\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { schemas } from '../client/schemas';\nimport { CreateTaskRequest } from '../client/models';\nimport { useCreateTask } from '../hooks/useTasks';\nimport { toast } from 'react-hot-toast';\nimport { getErrorMessage } from '../utils/errorHandling';\n\nexport const TaskForm = () => {\n  const createTaskMutation = useCreateTask();\n  \n  // Use the schema from the client for validation\n  const {\n    register,\n    handleSubmit,\n    reset,\n    formState: { errors, isSubmitting }\n  } = useForm<CreateTaskRequest>({\n    resolver: zodResolver(schemas.CreateTaskRequestSchema),\n    defaultValues: {\n      title: '',\n      description: '',\n      dueDate: new Date().toISOString().split('T')[0],\n      priority: 'medium'\n    }\n  });\n  \n  const onSubmit = async (data: CreateTaskRequest) => {\n    try {\n      await createTaskMutation.mutateAsync(data);\n      toast.success('Task created successfully');\n      reset();\n    } catch (error) {\n      toast.error(`Failed to create task: ${getErrorMessage(error)}`);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit(onSubmit)} className=\"space-y-4\">\n      <div>\n        <label htmlFor=\"title\" className=\"block text-sm font-medium text-gray-700\">\n          Title\n        </label>\n        <input\n          id=\"title\"\n          type=\"text\"\n          {...register('title')}\n          className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n        />\n        {errors.title && (\n          <p className=\"mt-1 text-sm text-red-600\">{errors.title.message}</p>\n        )}\n      </div>\n      \n      <div>\n        <label htmlFor=\"description\" className=\"block text-sm font-medium text-gray-700\">\n          Description\n        </label>\n        <textarea\n          id=\"description\"\n          {...register('description')}\n          rows={3}\n          className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n        />\n        {errors.description && (\n          <p className=\"mt-1 text-sm text-red-600\">{errors.description.message}</p>\n        )}\n      </div>\n      \n      <div>\n        <label htmlFor=\"dueDate\" className=\"block text-sm font-medium text-gray-700\">\n          Due Date\n        </label>\n        <input\n          id=\"dueDate\"\n          type=\"date\"\n          {...register('dueDate')}\n          className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n        />\n        {errors.dueDate && (\n          <p className=\"mt-1 text-sm text-red-600\">{errors.dueDate.message}</p>\n        )}\n      </div>\n      \n      <div>\n        <label htmlFor=\"priority\" className=\"block text-sm font-medium text-gray-700\">\n          Priority\n        </label>\n        <select\n          id=\"priority\"\n          {...register('priority')}\n          className=\"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n        >\n          <option value=\"low\">Low</option>\n          <option value=\"medium\">Medium</option>\n          <option value=\"high\">High</option>\n        </select>\n        {errors.priority && (\n          <p className=\"mt-1 text-sm text-red-600\">{errors.priority.message}</p>\n        )}\n      </div>\n      \n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className=\"inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50\"\n      >\n        {isSubmitting ? 'Creating...' : 'Create Task'}\n      </button>\n    </form>\n  );\n};\n```",
        "testStrategy": "1. Test form validation with valid and invalid inputs\n2. Verify error messages display correctly for validation errors\n3. Test form submission with mock API calls\n4. Test form reset after successful submission\n5. Test error handling for failed submissions\n6. Verify form uses the correct schema from the client\n7. Test with various input combinations to ensure all validation rules work",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Update Data Display Components",
        "description": "Update all data display components to match new API response structures, ensuring proper typing and handling of data.",
        "details": "1. Identify all components that display data from API responses\n2. Update component props to use types from models.ts\n3. Update rendering logic to match new data structures\n4. Add proper null/undefined checks\n5. Implement proper date formatting for date fields\n6. Update any numeric formatting to match API types\n\nExample update for a JobMetrics component:\n```typescript\nimport { JobMetric } from '../client/models';\nimport { formatDate } from '../utils/dateUtils';\nimport { formatNumber } from '../utils/numberUtils';\n\ninterface JobMetricsDisplayProps {\n  metrics: JobMetric[];\n}\n\nexport const JobMetricsDisplay = ({ metrics }: JobMetricsDisplayProps) => {\n  // Group metrics by category\n  const metricsByCategory = metrics.reduce((acc, metric) => {\n    if (!acc[metric.category]) {\n      acc[metric.category] = [];\n    }\n    acc[metric.category].push(metric);\n    return acc;\n  }, {} as Record<string, JobMetric[]>);\n  \n  return (\n    <div className=\"space-y-6\">\n      {Object.entries(metricsByCategory).map(([category, categoryMetrics]) => (\n        <div key={category} className=\"border rounded-lg p-4\">\n          <h3 className=\"text-lg font-medium mb-3\">{category}</h3>\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n            {categoryMetrics.map(metric => (\n              <div key={metric.id} className=\"bg-gray-50 p-3 rounded\">\n                <p className=\"text-sm text-gray-500\">{metric.name}</p>\n                <p className=\"text-xl font-semibold\">\n                  {metric.type === 'number' \n                    ? formatNumber(metric.value) \n                    : metric.value}\n                </p>\n                <p className=\"text-xs text-gray-400\">\n                  Last updated: {formatDate(metric.updatedAt)}\n                </p>\n              </div>\n            ))}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n};\n```\n\nCreate utility functions for consistent formatting:\n```typescript\n// dateUtils.ts\nexport const formatDate = (dateString: string): string => {\n  const date = new Date(dateString);\n  return new Intl.DateTimeFormat('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit'\n  }).format(date);\n};\n\n// numberUtils.ts\nexport const formatNumber = (value: number | string): string => {\n  // Ensure value is a number\n  const num = typeof value === 'string' ? parseFloat(value) : value;\n  \n  // Handle NaN\n  if (isNaN(num)) return '0';\n  \n  // Format with appropriate precision\n  return new Intl.NumberFormat('en-US', {\n    maximumFractionDigits: 2\n  }).format(num);\n};\n```",
        "testStrategy": "1. Write unit tests for each updated component\n2. Test with various mock data structures\n3. Test edge cases (empty arrays, null values, etc.)\n4. Test date and number formatting\n5. Verify components render correctly with the new data structure\n6. Test responsive design with different screen sizes\n7. Test accessibility of the updated components",
        "priority": "medium",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Type Safety Improvements",
        "description": "Replace any remaining 'any' or 'Record<string, unknown>' types in components with proper types from the client models.",
        "details": "1. Scan the codebase for any usage of 'any' or 'Record<string, unknown>' types\n2. Replace generic types with specific types from models.ts\n3. Add type guards where needed for runtime type checking\n4. Update function parameters and return types\n5. Add proper TypeScript interfaces for component props\n6. Update event handler types\n\nExample type improvements:\n```typescript\n// Before\nconst handleSubmit = (data: any) => {\n  // Submit data\n};\n\n// After\nimport { CreateUserRequest } from '../client/models';\n\nconst handleSubmit = (data: CreateUserRequest) => {\n  // Submit data\n};\n```\n\nExample type guard implementation:\n```typescript\nimport { Task, User, Project } from '../client/models';\n\n// Type guard for Task\nexport const isTask = (item: unknown): item is Task => {\n  return (\n    typeof item === 'object' &&\n    item !== null &&\n    'id' in item &&\n    'title' in item &&\n    'status' in item\n  );\n};\n\n// Type guard for API response\nexport const isApiErrorResponse = (error: unknown): error is { message: string; code: string } => {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    'code' in error\n  );\n};\n\n// Usage in component\nconst handleError = (error: unknown) => {\n  if (isApiErrorResponse(error)) {\n    toast.error(`Error ${error.code}: ${error.message}`);\n  } else {\n    toast.error('An unknown error occurred');\n  }\n};\n```",
        "testStrategy": "1. Run TypeScript compiler to verify no type errors remain\n2. Test type guards with various input types\n3. Verify components accept the correct prop types\n4. Test edge cases where type conversions might be needed\n5. Verify event handlers have proper typing\n6. Run ESLint with TypeScript rules to catch any remaining issues",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Performance Optimizations",
        "description": "Optimize component performance with proper caching strategies, pagination, and memoization.",
        "details": "1. Configure React Query for optimal caching:\n   - Set appropriate staleTime and cacheTime values\n   - Implement query key factories for consistent keys\n   - Add prefetching for anticipated data needs\n\n2. Add pagination support for list queries:\n   - Update hooks to accept pagination parameters\n   - Implement UI components for pagination controls\n   - Add infinite scrolling where appropriate\n\n3. Optimize re-renders with proper memoization:\n   - Use React.memo for pure components\n   - Use useMemo and useCallback hooks for expensive calculations and callbacks\n   - Implement proper dependency arrays\n\n4. Update query invalidation strategies:\n   - Implement targeted invalidation instead of broad invalidations\n   - Use optimistic updates for better UX\n\nExample implementation:\n```typescript\n// Query key factory\nimport { QueryKey } from '@tanstack/react-query';\n\nexport const queryKeys = {\n  tasks: {\n    all: ['tasks'] as const,\n    lists: () => [...queryKeys.tasks.all, 'list'] as const,\n    list: (filters: string) => [...queryKeys.tasks.lists(), { filters }] as const,\n    details: () => [...queryKeys.tasks.all, 'detail'] as const,\n    detail: (id: string) => [...queryKeys.tasks.details(), id] as const,\n  },\n  // Add other entities\n};\n\n// Paginated hook\nexport const useTasksList = (page = 1, limit = 10, filters?: Record<string, string>) => {\n  const queryKey = queryKeys.tasks.list(JSON.stringify(filters));\n  \n  return useQuery(\n    queryKey,\n    () => services.tasks.getTasks({ page, limit, ...filters }),\n    {\n      keepPreviousData: true,\n      staleTime: 5 * 60 * 1000, // 5 minutes\n    }\n  );\n};\n\n// Optimized component with memoization\nimport React, { useMemo, useCallback } from 'react';\n\ninterface TaskItemProps {\n  task: Task;\n  onStatusChange: (taskId: string, status: string) => void;\n}\n\nexport const TaskItem = React.memo(({ task, onStatusChange }: TaskItemProps) => {\n  // Memoize derived data\n  const isOverdue = useMemo(() => {\n    const dueDate = new Date(task.dueDate);\n    return dueDate < new Date() && task.status !== 'completed';\n  }, [task.dueDate, task.status]);\n  \n  // Memoize callbacks\n  const handleStatusChange = useCallback(() => {\n    const newStatus = task.status === 'completed' ? 'pending' : 'completed';\n    onStatusChange(task.id, newStatus);\n  }, [task.id, task.status, onStatusChange]);\n  \n  return (\n    <div className={`p-4 border rounded ${isOverdue ? 'border-red-300 bg-red-50' : 'border-gray-200'}`}>\n      <h3 className=\"font-medium\">{task.title}</h3>\n      <p className=\"text-sm text-gray-500\">{task.description}</p>\n      <div className=\"mt-2 flex justify-between items-center\">\n        <span className=\"text-xs\">\n          Due: {new Date(task.dueDate).toLocaleDateString()}\n        </span>\n        <button\n          onClick={handleStatusChange}\n          className={`px-2 py-1 rounded text-xs ${task.status === 'completed' ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}`}\n        >\n          {task.status === 'completed' ? 'Completed' : 'Mark Complete'}\n        </button>\n      </div>\n    </div>\n  );\n});\n\n// Pagination component\nexport const Pagination = ({ \n  currentPage, \n  totalPages, \n  onPageChange \n}: { \n  currentPage: number; \n  totalPages: number; \n  onPageChange: (page: number) => void \n}) => {\n  return (\n    <div className=\"flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6\">\n      <div className=\"flex flex-1 justify-between sm:hidden\">\n        <button\n          onClick={() => onPageChange(currentPage - 1)}\n          disabled={currentPage === 1}\n          className=\"relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50\"\n        >\n          Previous\n        </button>\n        <button\n          onClick={() => onPageChange(currentPage + 1)}\n          disabled={currentPage === totalPages}\n          className=\"relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50\"\n        >\n          Next\n        </button>\n      </div>\n      <div className=\"hidden sm:flex sm:flex-1 sm:items-center sm:justify-between\">\n        <div>\n          <p className=\"text-sm text-gray-700\">\n            Showing page <span className=\"font-medium\">{currentPage}</span> of{' '}\n            <span className=\"font-medium\">{totalPages}</span>\n          </p>\n        </div>\n        <div>\n          <nav className=\"isolate inline-flex -space-x-px rounded-md shadow-sm\" aria-label=\"Pagination\">\n            {/* Pagination buttons */}\n            {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {\n              const pageNumber = currentPage - 2 + i;\n              if (pageNumber < 1 || pageNumber > totalPages) return null;\n              \n              return (\n                <button\n                  key={pageNumber}\n                  onClick={() => onPageChange(pageNumber)}\n                  aria-current={pageNumber === currentPage ? 'page' : undefined}\n                  className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${pageNumber === currentPage\n                    ? 'z-10 bg-indigo-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600'\n                    : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:outline-offset-0'\n                  }`}\n                >\n                  {pageNumber}\n                </button>\n              );\n            })}\n          </nav>\n        </div>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Measure and compare component render performance before and after optimizations\n2. Test caching behavior with React Query DevTools\n3. Verify pagination works correctly with mock API responses\n4. Test memoization effectiveness by monitoring re-renders\n5. Test optimistic updates for user actions\n6. Verify query invalidation strategies work as expected\n7. Test with large datasets to ensure performance at scale",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Comprehensive Testing Suite",
        "description": "Create a comprehensive testing suite for all updated components and hooks to ensure they work correctly with the new API structure.",
        "details": "1. Set up testing environment with Jest and React Testing Library\n2. Configure MSW (Mock Service Worker) for API mocking\n3. Create test fixtures that match the updated API response structures\n4. Write unit tests for all hooks\n5. Write component tests for all updated components\n6. Test error scenarios and loading states\n7. Test form validation and submission\n\nExample test setup:\n```typescript\n// setupTests.ts\nimport '@testing-library/jest-dom';\nimport { server } from './mocks/server';\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n```\n\nExample API mocks:\n```typescript\n// mocks/handlers.ts\nimport { rest } from 'msw';\nimport { Task } from '../client/models';\n\nconst mockTasks: Task[] = [\n  {\n    id: '1',\n    title: 'Complete project',\n    description: 'Finish the project by Friday',\n    status: 'pending',\n    priority: 'high',\n    dueDate: '2023-12-01T00:00:00.000Z',\n    createdAt: '2023-11-01T00:00:00.000Z',\n    updatedAt: '2023-11-01T00:00:00.000Z'\n  },\n  // Add more mock tasks\n];\n\nexport const handlers = [\n  rest.get('/api/tasks', (req, res, ctx) => {\n    return res(ctx.status(200), ctx.json(mockTasks));\n  }),\n  \n  rest.post('/api/tasks', (req, res, ctx) => {\n    const newTask = {\n      id: Date.now().toString(),\n      ...req.body,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    return res(ctx.status(201), ctx.json(newTask));\n  }),\n  \n  rest.put('/api/tasks/:id', (req, res, ctx) => {\n    const { id } = req.params;\n    const existingTask = mockTasks.find(task => task.id === id);\n    \n    if (!existingTask) {\n      return res(ctx.status(404), ctx.json({ message: 'Task not found' }));\n    }\n    \n    const updatedTask = {\n      ...existingTask,\n      ...req.body,\n      updatedAt: new Date().toISOString()\n    };\n    \n    return res(ctx.status(200), ctx.json(updatedTask));\n  }),\n  \n  // Add more API mocks\n];\n```\n\nExample hook test:\n```typescript\nimport { renderHook, waitFor } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { useTasks } from '../hooks/useTasks';\n\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n      },\n    },\n  });\n  \n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n};\n\ndescribe('useTasks', () => {\n  it('should fetch tasks successfully', async () => {\n    const { result } = renderHook(() => useTasks(), {\n      wrapper: createWrapper(),\n    });\n    \n    // Initially in loading state\n    expect(result.current.isLoading).toBe(true);\n    \n    // Wait for the query to resolve\n    await waitFor(() => expect(result.current.isSuccess).toBe(true));\n    \n    // Check if data is returned correctly\n    expect(result.current.data).toHaveLength(2);\n    expect(result.current.data?.[0].title).toBe('Complete project');\n  });\n  \n  // Add more tests\n});\n```\n\nExample component test:\n```typescript\nimport { render, screen, waitFor, fireEvent } from '@testing-library/react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { TodaysTasks } from '../components/TodaysTasks';\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retry: false,\n    },\n  },\n});\n\nconst wrapper = ({ children }: { children: React.ReactNode }) => (\n  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n);\n\ndescribe('TodaysTasks', () => {\n  beforeEach(() => {\n    queryClient.clear();\n  });\n  \n  it('renders loading state initially', () => {\n    render(<TodaysTasks />, { wrapper });\n    expect(screen.getByText(/loading/i)).toBeInTheDocument();\n  });\n  \n  it('renders tasks after loading', async () => {\n    render(<TodaysTasks />, { wrapper });\n    \n    // Wait for tasks to load\n    await waitFor(() => {\n      expect(screen.getByText('Complete project')).toBeInTheDocument();\n    });\n  });\n  \n  it('toggles task status when clicked', async () => {\n    render(<TodaysTasks />, { wrapper });\n    \n    // Wait for tasks to load\n    await waitFor(() => {\n      expect(screen.getByText('Complete project')).toBeInTheDocument();\n    });\n    \n    // Click the toggle button\n    fireEvent.click(screen.getByLabelText('Mark as complete'));\n    \n    // Verify the task status changes\n    await waitFor(() => {\n      expect(screen.getByLabelText('Mark as incomplete')).toBeInTheDocument();\n    });\n  });\n  \n  // Add more tests\n});\n```",
        "testStrategy": "1. Aim for at least 80% test coverage for updated components and hooks\n2. Test all major user flows and interactions\n3. Test edge cases and error scenarios\n4. Run tests in CI/CD pipeline to catch regressions\n5. Use snapshot testing for UI components\n6. Test accessibility compliance\n7. Test performance critical components with benchmarking",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Final Integration and Documentation",
        "description": "Perform final integration testing, create documentation for the updated components, and prepare for deployment.",
        "details": "1. Create a comprehensive README.md with documentation on:\n   - Updated hooks and their usage\n   - Component changes\n   - Error handling approach\n   - Performance optimizations\n\n2. Add JSDoc comments to all hooks and components\n\n3. Create usage examples for common patterns\n\n4. Perform final integration testing:\n   - Test all components together\n   - Verify no regressions in existing functionality\n   - Test with realistic data volumes\n\n5. Create a migration guide for developers:\n   - Document breaking changes\n   - Provide examples of before/after code\n   - List common pitfalls to avoid\n\nExample documentation:\n```markdown\n# Frontend API Integration Updates\n\n## Overview\nThis document outlines the updates made to frontend components and hooks to integrate with the updated API client.\n\n## Updated Hooks\n\n### Task Hooks\n\n#### `useTasks`\nFetches a list of tasks with optional filtering.\n\n```typescript\nconst { data, isLoading, error } = useTasks({\n  status: 'pending',\n  priority: 'high'\n});\n```\n\n#### `useTask`\nFetches a single task by ID.\n\n```typescript\nconst { data, isLoading, error } = useTask(taskId);\n```\n\n#### `useCreateTask`\nCreates a new task.\n\n```typescript\nconst createTaskMutation = useCreateTask();\n\n// In your form submit handler\nconst handleSubmit = async (data: CreateTaskRequest) => {\n  try {\n    await createTaskMutation.mutateAsync(data);\n    toast.success('Task created successfully');\n  } catch (error) {\n    toast.error(`Failed to create task: ${getErrorMessage(error)}`);\n  }\n};\n```\n\n## Error Handling\n\nAll components now use a consistent error handling approach:\n\n1. API errors are caught and displayed using toast notifications\n2. Components display appropriate error states\n3. The `getErrorMessage` utility is used to extract user-friendly error messages\n\n## Performance Optimizations\n\n1. React Query is configured with appropriate caching settings\n2. Components use memoization to prevent unnecessary re-renders\n3. List components support pagination\n4. Optimistic updates are implemented for better UX\n\n## Migration Guide\n\n### Updating Components\n\n#### Before:\n```typescript\nconst MyComponent = () => {\n  const [tasks, setTasks] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  \n  useEffect(() => {\n    const fetchTasks = async () => {\n      try {\n        const response = await fetch('/api/tasks');\n        const data = await response.json();\n        setTasks(data);\n      } catch (err) {\n        setError('Failed to fetch tasks');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchTasks();\n  }, []);\n  \n  // Component rendering\n};\n```\n\n#### After:\n```typescript\nimport { useTasks } from '../hooks/useTasks';\nimport { getErrorMessage } from '../utils/errorHandling';\nimport { LoadingSpinner } from './LoadingSpinner';\nimport { ErrorDisplay } from './ErrorDisplay';\n\nconst MyComponent = () => {\n  const { data: tasks, isLoading, error, refetch } = useTasks();\n  \n  if (isLoading) return <LoadingSpinner />;\n  \n  if (error) {\n    return <ErrorDisplay message={getErrorMessage(error)} retry={refetch} />;\n  }\n  \n  // Component rendering\n};\n```\n\n## Common Pitfalls\n\n1. **Type Mismatches**: Always use types from the client models instead of defining your own\n2. **Error Handling**: Don't use generic error messages; use the getErrorMessage utility\n3. **Caching**: Be aware of React Query's caching behavior when updating data\n4. **Dependencies**: Ensure proper dependency arrays in useEffect and useMemo hooks\n```\n\nExample JSDoc comments:\n```typescript\n/**\n * Hook to fetch tasks with optional filtering\n * @param filters - Optional filters to apply to the task list\n * @returns Query result with tasks data, loading state, and error\n */\nexport const useTasks = (filters?: TaskFilters) => {\n  return useQuery<Task[], Error>(\n    queryKeys.tasks.list(JSON.stringify(filters)),\n    () => services.tasks.getTasks(filters),\n    { staleTime: 5 * 60 * 1000 }\n  );\n};\n\n/**\n * Component to display a list of today's tasks\n * Allows toggling task completion status\n */\nexport const TodaysTasks = () => {\n  // Component implementation\n};\n```",
        "testStrategy": "1. Perform end-to-end testing of the entire application\n2. Verify all components work together correctly\n3. Test with realistic data volumes\n4. Verify documentation accuracy\n5. Have other developers review the documentation\n6. Test the application in different browsers\n7. Verify accessibility compliance\n8. Test performance under load",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-10T08:17:39.157Z",
      "updated": "2025-08-10T16:51:34.276Z",
      "description": "Tasks for master context"
    }
  }
}